// Generated by CoffeeScript 1.7.1
(function() {
  var canvas, drawScene, getShader, gl, horizAspect, initBuffers, initPyramidBuffers, initShaders, initSphereBuffers, initStats, initWebGL, lastUpdateTime, loadIdentity, moveSpeed, multMatrix, mvMatrix, mvMatrixStack, mvPopMatrix, mvPushMatrix, mvRotate, mvTranslate, perspectiveMatrix, rotation, setColorUniform, setMatrixUniforms, shaderProgram, sphereIndexBuffer, sphereVertexPositionBuffer, start, stats, triangleVertexIndices, triangleVertices, triangleVerticesBuffer, triangleVerticesColorBuffer, triangleVerticesIndexBuffer, vertexColorAttribute, vertexPositionAttribute, xIncValue, yIncValue, zIncValue;

  gl = canvas = shaderProgram = null;

  horizAspect = 640.0 / 480.0;

  stats = null;

  vertexPositionAttribute = vertexColorAttribute = null;

  triangleVerticesBuffer = triangleVerticesColorBuffer = triangleVerticesIndexBuffer = triangleVertexIndices = triangleVertices = null;

  sphereVertexPositionBuffer = sphereIndexBuffer = null;

  rotation = lastUpdateTime = 0;

  xIncValue = 0.2;

  yIncValue = -0.4;

  zIncValue = 0;

  moveSpeed = 1;

  mvMatrix = perspectiveMatrix = null;

  mvMatrixStack = [];

  $(document).ready(function() {
    initStats();
    return start();
  });

  start = function() {
    canvas = $('canvas.glcanvas')[0];
    canvas.appendChild(stats.domElement);
    $('#stats').appendTo('#container');
    initWebGL(canvas);
    if (gl) {
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.clearDepth(1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      initShaders();
      initBuffers();
      return drawScene();
    }
  };

  initWebGL = function(canvas) {
    var error;
    gl = null;
    try {
      gl = canvas.getContext('webgl');
    } catch (_error) {
      error = _error;
      console.log(error);
    }
    if (!gl) {
      return console.log('Unable to initialize WebGL. Your browser may not support it.');
    }
  };

  initShaders = function() {
    var fragmentShader, vertexShader;
    vertexShader = getShader(gl, 'shader-vs');
    fragmentShader = getShader(gl, 'shader-fs');
    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      console.log('Unable to initialize the shader program.');
    }
    gl.useProgram(shaderProgram);
    vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
    return gl.enableVertexAttribArray(vertexPositionAttribute);
  };

  initBuffers = function() {
    return initSphereBuffers(30, 30, 1.5);
  };

  drawScene = function() {
    var absmCos, currentTime, delta, mCos, mSin, vecX, vecY;
    window.requestAnimationFrame(drawScene, canvas);
    stats.begin();
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    perspectiveMatrix = makePerspective(45, 640.0 / 480.0, 0.1, 100.0);
    loadIdentity();
    moveSpeed += 0.0145001;
    mCos = Math.cos(moveSpeed);
    absmCos = Math.abs(mCos);
    mSin = Math.sin(moveSpeed);
    vecX = 2.5 * mCos;
    vecY = 1.5 * mSin;
    mvTranslate([vecX, vecY, -8.0]);
    mvPushMatrix();
    mvRotate(rotation, [1, 1, 0]);
    setColorUniform(0.0, 0.0, 0.0, 1.0);
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
    gl.vertexAttribPointer(vertexPositionAttribute, sphereVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);
    gl.drawElements(gl.LINE_STRIP, sphereIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    setMatrixUniforms();
    mvPopMatrix();
    currentTime = (new Date).getTime();
    if (lastUpdateTime) {
      delta = currentTime - lastUpdateTime;
      rotation += (30 * delta) / 1000.0;
    }
    lastUpdateTime = currentTime;
    return stats.end();
  };

  initSphereBuffers = function(latitudeBands, longitudeBands, radius) {
    var cosPhi, cosTheta, first, indexData, latNumber, longNumber, phi, second, sinPhi, sinTheta, theta, vertexPositionData, x, y, z, _i, _j, _k, _l, _ref, _ref1;
    indexData = [];
    vertexPositionData = [];
    for (latNumber = _i = 0; _i <= latitudeBands; latNumber = _i += 1) {
      console.log(latNumber);
      theta = latNumber * Math.PI / latitudeBands;
      sinTheta = Math.sin(theta);
      cosTheta = Math.cos(theta);
      for (longNumber = _j = 0; _j <= longitudeBands; longNumber = _j += 1) {
        phi = longNumber * 2 * Math.PI / longitudeBands;
        sinPhi = Math.sin(phi);
        cosPhi = Math.cos(phi);
        x = cosPhi * sinTheta;
        y = cosTheta;
        z = sinPhi * sinTheta;
        vertexPositionData.push(radius * x);
        vertexPositionData.push(radius * y);
        vertexPositionData.push(radius * z);
      }
    }
    for (latNumber = _k = 0, _ref = latitudeBands - 1; _k <= _ref; latNumber = _k += 1) {
      for (longNumber = _l = 0, _ref1 = longitudeBands - 1; _l <= _ref1; longNumber = _l += 1) {
        first = (latNumber * (longitudeBands + 1)) + longNumber;
        second = first + longitudeBands + 1;
        indexData.push(first);
        indexData.push(second);
        indexData.push(first + 1);
        indexData.push(second);
        indexData.push(second + 1);
        indexData.push(first + 1);
      }
    }
    sphereVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, sphereVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
    sphereVertexPositionBuffer.itemSize = 3;
    sphereVertexPositionBuffer.numItems = vertexPositionData.length / 3;
    sphereIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphereIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
    sphereIndexBuffer.itemSize = 1;
    return sphereIndexBuffer.numItems = indexData.length;
  };

  initPyramidBuffers = function() {
    triangleVerticesBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, triangleVerticesBuffer);
    triangleVertices = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 0.0, 1.0, 0.0, -1.0, -1.0, -1.0, 0.0, 1.0, 0.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 0.0, 1.0, 0.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 0.0, 1.0, 0.0];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertices), gl.STATIC_DRAW);
    triangleVerticesIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, triangleVerticesIndexBuffer);
    triangleVertexIndices = [0, 1, 2, 3, 4, 5, 6, 7, 8, 6, 8, 9, 10, 11, 12, 13, 14, 15];
    return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangleVertexIndices), gl.STATIC_DRAW);
  };

  initStats = function() {
    stats = new Stats();
    stats.setMode(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    return stats.domElement.style.zIndex = 100;
  };

  getShader = function(gl, id) {
    var currentChild, shader, shaderScript, theSource;
    theSource = currentChild = shader = null;
    shaderScript = document.getElementById(id);
    if (!shaderScript) {
      return null;
    }
    theSource = '';
    currentChild = shaderScript.firstChild;
    while (currentChild) {
      if (currentChild.nodeType === 3) {
        theSource += currentChild.textContent;
      }
      currentChild = currentChild.nextSibling;
    }
    if (shaderScript.type === 'x-shader/x-fragment') {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type === 'x-shader/x-vertex') {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      return null;
    }
    gl.shaderSource(shader, theSource);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.log('An error occurred compiling the shaders: ', gl.getShaderInfoLog(shader));
    }
    return shader;
  };

  loadIdentity = function() {
    return mvMatrix = Matrix.I(4);
  };

  multMatrix = function(m) {
    return mvMatrix = mvMatrix.x(m);
  };

  mvTranslate = function(v) {
    return multMatrix(Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4());
  };

  setMatrixUniforms = function() {
    var mvUniform, pUniform;
    pUniform = gl.getUniformLocation(shaderProgram, 'uPMatrix');
    gl.uniformMatrix4fv(pUniform, false, new Float32Array(perspectiveMatrix.flatten()));
    mvUniform = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
    return gl.uniformMatrix4fv(mvUniform, false, new Float32Array(mvMatrix.flatten()));
  };

  setColorUniform = function(factorR, factorG, factorB, factorA) {
    var colorUniform, fragColor;
    fragColor = [1.0 * factorR, 1.0 * factorG, 1.0 * factorB, 1.0 * factorA];
    colorUniform = gl.getUniformLocation(shaderProgram, 'colorUniform');
    return gl.uniform4fv(colorUniform, new Float32Array(fragColor));
  };

  mvPushMatrix = function(m) {
    if (m) {
      mvMatrixStack.push(m.dup());
      return mvMatrix = m.dup();
    } else {
      return mvMatrixStack.push(mvMatrix.dup());
    }
  };

  mvPopMatrix = function() {
    if (!mvMatrixStack.length) {
      throw 'Cant pop from an empty matrix stack.';
    }
    mvMatrix = mvMatrixStack.pop();
    return mvMatrix;
  };

  mvRotate = function(angle, v) {
    var inRadians, m;
    inRadians = angle * (Math.PI / 180.0);
    m = Matrix.Rotation(inRadians, $V([v[0], v[1], v[2]])).ensure4x4();
    return multMatrix(m);
  };

}).call(this);
